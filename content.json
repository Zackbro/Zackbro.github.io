{"meta":{"title":"Zack’s Notes","subtitle":null,"description":"向大家学习人生经验。","author":"Zack","url":"https://pyramidk.github.io"},"pages":[{"title":"","date":"2017-05-26T10:24:24.015Z","updated":"2017-05-26T10:24:24.015Z","comments":false,"path":"categories/index.html","permalink":"https://pyramidk.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-26T10:24:36.664Z","updated":"2017-05-26T10:24:36.664Z","comments":false,"path":"tags/index.html","permalink":"https://pyramidk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS数据结构和算法笔记（5）","slug":"learing-datastrc3","date":"2017-01-20T10:41:42.000Z","updated":"2017-02-18T07:27:04.468Z","comments":true,"path":"2017/01/20/learing-datastrc3/","link":"","permalink":"https://pyramidk.github.io/2017/01/20/learing-datastrc3/","excerpt":"1.散列后的数据可以快速的插入或取用，散列使用的数据结构叫做散列表。 2.使用散列表存储数据时，通过一个散列函数将键映射为一个数组，这个数字的范围是0到散列表的长度。 3.用散列函数时，存在将2个键映射成同一个值的可能，这种现象称为碰撞。","text":"1.散列后的数据可以快速的插入或取用，散列使用的数据结构叫做散列表。 2.使用散列表存储数据时，通过一个散列函数将键映射为一个数组，这个数字的范围是0到散列表的长度。 3.用散列函数时，存在将2个键映射成同一个值的可能，这种现象称为碰撞。 4.保留余数法。 5.集合是一种包含不同元素的数据结构。2个特性： 无序，不同。 6.树是一种非线性数据结构，以分层的方式存储数据。 7.树最上面的节点称为根节点。 8.父节点： 节点下面连接多个节点。这些下面的节点称为子节点。 9.没有任何子节点的节点称为叶子节点。 10.二叉树是一种特殊的树，它的字节点树不超过2个。 11.从一个节点到另一个节点的这一组边称为路径，以某种特定的顺序访问树中所有的节点称为树的遍历。 12.每个节点都有一个与之相关的值，该值为键。 13.二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点，较大右节点。 14.中序遍历按照节点上的键值，以升序访问BST上的所有节点。 15.先序遍历先访问根节点，然后以同样方式访问左子树和右子树。 16.后序遍历先访问叶子节点，从左子树到右子树，再到根节点。 17.图由边的集合及顶点的结合组成。 18.边由顶点对定义（v1,v2）,v1和v2分别是图中的2个顶点。 19 顶点也有权重，也称为成本。如果一个图的顶点是有序的，则可称为向图。如果图是无序的，则称之为无序图，或无向图。 20.交换的原则就是将其中一个元素用一个变量存储起来，让这个元素等于另一元素，最后将另一元素等于当前变量。","categories":[],"tags":[{"name":"数据结构笔记","slug":"数据结构笔记","permalink":"https://pyramidk.github.io/tags/数据结构笔记/"}]},{"title":"Vim安装与配置（Windows）","slug":"vim","date":"2017-01-19T09:20:39.571Z","updated":"2017-02-18T06:11:40.163Z","comments":true,"path":"2017/01/19/vim/","link":"","permalink":"https://pyramidk.github.io/2017/01/19/vim/","excerpt":"Vim安装 去官网下载vim，最好下载安装文件而不是压缩包。 在window下安装在program files(86)文件下运行git命令行会报错，而且需要权限。可以尝试安装在其他地方。 正确安装之后可以在vim文件夹下看到配置文件_vimrc。","text":"Vim安装 去官网下载vim，最好下载安装文件而不是压缩包。 在window下安装在program files(86)文件下运行git命令行会报错，而且需要权限。可以尝试安装在其他地方。 正确安装之后可以在vim文件夹下看到配置文件_vimrc。 安装vim插件管理vundle注意：在windows下需要先安装git和配置curl，因为需要curl在命令行中运行，所以需要curl.cmd，github介绍文件如是说。 Vundle for Windows: 官网介绍 下载msysgit，一路安装，在环境配置的地方，选择第二个“run git from the windows command prompt”。 cmd输入git –versions查看是否成功。 配置curl：在安装的Git/cmd/新建curl.cmd,里面添加如下内容： 12345678910111213@rem Do not use \"echo off\" to not affect any child calls.@setlocal @rem Get the abolute path to the parent directory, which is assumed to be the@rem Git installation root.@for /F \"delims=\" %%I in (\"%~dp0..\") do @set git_install_root=%%~fI@set PATH=%git_install_root%\\bin;%git_install_root%\\mingw\\bin;%git_install_root%\\mingw64\\bin;%PATH%@rem !!!!!!! For 64bit msysgit, replace 'mingw' above with 'mingw64' !!!!!!! @if not exist \"%HOME%\" @set HOME=%HOMEDRIVE%%HOMEPATH%@if not exist \"%HOME%\" @set HOME=%USERPROFILE% @curl.exe %* cmd运行curl –version查看是否成功 安装Vundle：git clone https://github.com/gmarik/Vundle.vim.git C:\\Program Files (x86)\\Vim\\vimfiles\\bundle\\Vundle.vim； 某些教程上让直接git clone，但在默认的vim安装文件夹下会报错，解决方法是安装vim在其他文件里；或者git clone在其他文件夹下，然后复制到vim相应的文件夹下。 最后配置_vimrc文件就行，然后通过在Gvim里是使用：BundleInstall命令，可以运行即为成功。","categories":[],"tags":[]},{"title":"JS数据结构和算法笔记（4）","slug":"Algorithm2","date":"2017-01-16T11:53:38.525Z","updated":"2017-02-18T07:19:33.964Z","comments":true,"path":"2017/01/16/Algorithm2/","link":"","permalink":"https://pyramidk.github.io/2017/01/16/Algorithm2/","excerpt":"高级排序算法希尔排序在插入排序的基础上做了很大的改善。 它会首先比较距离较远的元素，使用这种方案可以使离正确位置很远的元素更快的回到合适的位置上。 希尔排序的工作原理是，通过定义一个间隔序列表示在排序过程中进行比较的元素之间有多远的间隔。","text":"高级排序算法希尔排序在插入排序的基础上做了很大的改善。 它会首先比较距离较远的元素，使用这种方案可以使离正确位置很远的元素更快的回到合适的位置上。 希尔排序的工作原理是，通过定义一个间隔序列表示在排序过程中进行比较的元素之间有多远的间隔。 归并排序把一系列排好序的子序列合并成一个大的完整序列。 我们需要2个排好序的子数组，先从最小的数据开始插入，最后合并得到第三个数组。 自底向上的归并排序：首先将数据及分解为一组只有一个元素的数组，然后通过创建一组左右子数组将它们慢慢合并起来，每次合并都保存一部分排好序的数据，直到最后都排好序。 快速排序首先在列表中选择一个元素作为基准值。 数据排序围绕基准值进行，将列表中小于基准值的元素移动到数组的底部，将大于基准值的元素移动到数组的顶部。 堆排序","categories":[],"tags":[]},{"title":"JS数据结构和算法笔记（3）","slug":"Algorithm","date":"2017-01-15T08:38:13.023Z","updated":"2017-02-18T07:19:24.752Z","comments":true,"path":"2017/01/15/Algorithm/","link":"","permalink":"https://pyramidk.github.io/2017/01/15/Algorithm/","excerpt":"排序算法基本排序算法其核心思想是指对一组数据按照一定顺序重新排列。重新排列时用到的技术是一组嵌套的for循环。其中外循环用于遍历数组的每一项，内循环则用于比较元素。","text":"排序算法基本排序算法其核心思想是指对一组数据按照一定顺序重新排列。重新排列时用到的技术是一组嵌套的for循环。其中外循环用于遍历数组的每一项，内循环则用于比较元素。 冒泡排序算法它是最慢的排序算法之一，也是最容易实现的排序算法。此算法会多次在数组中移动，比较相邻的数据，当左侧大于右侧时进行互换。选择排序算法选择排序从数组的开头开始，将第一个元素和其它元素进行比较，检查完所有的元素后，最小的元素会被放在数组的第一个位置，然后算法从第二个位置继续。当进行到数组倒数第二个位置时，所有的数据便完成了排序。选择排序会用到嵌套循环，外循环从数组的第一个元素移动到倒数第二个元素；内循环从第二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素，每次内循环迭代后，数组中最小的值都会被赋值到合适的位置。插入排序算法插入排序类似于人类按数字或字母排序，选择选中的元素将它插入到合适的位置。插入排序有2个循环。外循环将数组元素挨个移动，而内循环则对外循环选中的元素及它后面的那个元素进行比较，如果外循环中选中的元素比内循环选中的元素小，那么数组元素会向右移动，为内循环的这个元素腾出位置。","categories":[],"tags":[]},{"title":"JS数据结构和算法笔记（2）","slug":"learing-datastrc2","date":"2017-01-06T10:48:48.000Z","updated":"2017-02-18T07:20:29.166Z","comments":true,"path":"2017/01/06/learing-datastrc2/","link":"","permalink":"https://pyramidk.github.io/2017/01/06/learing-datastrc2/","excerpt":"1.散列后的数据可以快速的插入或取用，散列使用的数据结构叫做散列表 2.使用散列表存储数据时，通过一个散列函数将键映射为一个数组，这个数字的范围是0到散列表的长度。3.用散列函数时，存在将2个键映射成同一个值的可能，这种现象称为碰撞。","text":"1.散列后的数据可以快速的插入或取用，散列使用的数据结构叫做散列表 2.使用散列表存储数据时，通过一个散列函数将键映射为一个数组，这个数字的范围是0到散列表的长度。3.用散列函数时，存在将2个键映射成同一个值的可能，这种现象称为碰撞。 4.保留余数法。 5.集合是一种包含不同元素的数据结构。2个特性： 无序，不同。 6.树是一种非线性数据结构，以分层的方式存储数据。 7.树最上面的节点称为根节点。 8.父节点： 节点下面连接多个节点。这些下面的节点称为子节点。 9.没有任何子节点的节点称为叶子节点。 10.二叉树是一种特殊的树，它的字节点树不超过2个。 11.从一个节点到另一个节点的这一组边称为路径，以某种特定的顺序访问树中所有的节点称为树的遍历。 12.每个节点都有一个与之相关的值，该值为键。 13.二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点，较大右节点。 14.中序遍历按照节点上的键值，以升序访问BST上的所有节点。 15.先序遍历先访问根节点，然后以同样方式访问左子树和右子树。 16.后序遍历先访问叶子节点，从左子树到右子树，再到根节点。 17.图由边的集合及顶点的结合组成。 18.边由顶点对定义（v1,v2）,v1和v2分别是图中的2个顶点。 19.顶点也有权重，也称为成本。如果一个图的顶点是有序的，则可称为向图。如果图是无序的，则称之为无序图，或无向图。 20.交换的原则就是将其中一个元素用一个变量存储起来，让这个元素等于另一元素，最后将另一元素等于当前变量。","categories":[],"tags":[{"name":"数据结构笔记","slug":"数据结构笔记","permalink":"https://pyramidk.github.io/tags/数据结构笔记/"}]},{"title":"JS数据结构和算法笔记","slug":"learing-datastrc","date":"2017-01-05T10:29:48.000Z","updated":"2017-02-18T07:19:48.574Z","comments":true,"path":"2017/01/05/learing-datastrc/","link":"","permalink":"https://pyramidk.github.io/2017/01/05/learing-datastrc/","excerpt":"1.while循环： 在条件为真时执行 for循环：按执行次数执行一组语句 2.任何可以被递归定义的函数，都可以被改写为迭代式程序 3.Array.isArray()来判断一个对象是否为数组","text":"1.while循环： 在条件为真时执行 for循环：按执行次数执行一组语句 2.任何可以被递归定义的函数，都可以被改写为迭代式程序 3.Array.isArray()来判断一个对象是否为数组 4.浅复制：对一个数组进行复制，新的数组只是增加了一个对老数组的引用，修改老数组的值，新的也会变化。还有深复制。（p16）5.查找元素 6.index（） 存在返回索引，否则返回-1 7.将数组转化为字符串： join（）和toString（） 8.由已有数组创建新数组：concat（）和splice（起始索引，长度）也可用于增加和删除 9.数组添加：push，unshift 删除：pop， shift 10.从数组中间位置添加元素：splice（位置，0，要添加的元素） 11.排序：reverse，sort 12.不生成新数组的迭代器方法：forEach（）；every（）全为true，返回true；some（）一为true，返回true；reduce（） 13.生成新数组的迭代器方法：map（）；filter（）用于过滤一些东西 14.列表是一组有序的数据，每个列表中的数据称为元素。 15.栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出的数据结构。 16.适用栈来解决掉问题：数制间的相互转换；回文；模拟递归 17.队列是一种先进先出的数据结构，在队尾插入元素，在队首删除元素。 18.链表是由一组节点组成的集合，每个节点都使用一个对象的引用指向它的后继，指向另一个节点的引用叫做链。 19.数组元素靠它们的位置进行引用，链表元素是靠相互之间的关系进行引用。 20.双向链表，循环列表 21.字典：以键值对存储数据的数据结构 22.Object 类的 keys() 方法可以返回传入参数中存储的所有键。","categories":[],"tags":[{"name":"数据结构笔记","slug":"数据结构笔记","permalink":"https://pyramidk.github.io/tags/数据结构笔记/"}]},{"title":"Some notes","slug":"12.26","date":"2016-12-25T16:00:00.000Z","updated":"2017-02-24T10:55:19.018Z","comments":true,"path":"2016/12/26/12.26/","link":"","permalink":"https://pyramidk.github.io/2016/12/26/12.26/","excerpt":"","text":"1.自定义键盘指令 2.过滤器的变化，去掉了默认过滤器，需自定义过滤器（传参有变化） 3.动画 2.0 traansition 变为组件 4.router变化 loader 5.组件通信变化，去掉了双向绑定 6.按需加载相应组件bable-plugin-component 7.自定义组件加事件需要加native，@click。native=’get’ 8.bind的用法 9.icomoon 生成图标字体 10.crosswork安卓端 cordova iOS 11.移动端分辨率，像素 12.1像素边框，利用伪类实现一像素，然后通过class实现缩放不改变的效果 13.card-content-inner 去掉padding fotter 去掉flex 14.设备像素比，张鑫续 15.去除文字和图片之间的字体自带的默认间隔，将父元素的font-size设为0 16.span标签需要内容撑开。即使设置了宽高也没用。可以变为inline-block来占位 17.css， 影响宽高的写在前面，影响样式的在后 18.sticky footers w3cplus 19.对于数字的处理：例如：4.3这个数字，我们需要4和后面小数的进行判断 可尝试如下方法获取整数：Math.floor(4.3 *2)/2, 判断是否有小数 20.display: table 用于垂直居中，多行也可以 21.vue: ref给dom做一个标记（名字） $refs.名字就可以获得那个Dom 要注意nextick；dom的变化是在nexttick后渲染好的 22.圆形用border-radius=50% 实现；图标字体可用text-align: center来居中 23.vue dom更新是异步的，所以需要着重注意在￥nexttick 之后再触发一些事件 24.:href=”‘/gamedetail/‘+ item.id” vue绑定传参里的用法","categories":[],"tags":[]},{"title":"JavaScript语言精粹","slug":"JSEssential","date":"2016-12-06T10:48:48.000Z","updated":"2017-02-18T06:52:56.509Z","comments":true,"path":"2016/12/06/JSEssential/","link":"","permalink":"https://pyramidk.github.io/2016/12/06/JSEssential/","excerpt":"1.apply： 构建一个参数数组并让我们去调用函数，它允许我们选择this的值。可接收2个参数，第一个是绑定this的那个对象，第二个是参数。 2.函数里的参数数组，即arguments数组。缺点：它不是一个真正的数组，虽然拥有length属性，但缺少数组方法。 3.在函数前面加上new前缀来调用（即声明一个对象），且返回值不是一个对象，则返回this（该新对象）。","text":"1.apply： 构建一个参数数组并让我们去调用函数，它允许我们选择this的值。可接收2个参数，第一个是绑定this的那个对象，第二个是参数。 2.函数里的参数数组，即arguments数组。缺点：它不是一个真正的数组，虽然拥有length属性，但缺少数组方法。 3.在函数前面加上new前缀来调用（即声明一个对象），且返回值不是一个对象，则返回this（该新对象）。 4.js移除字符串末端空白的方法： 5.闭包？？？page52 访问的是实际变量而不是复制？ 6.for循环，那个事件处理器函数绑定了变量i，而不是函数在构造时变量i的值。修改前： 修改后： 定义了一个函数并立即传递i进去执行，而不是把一个函数赋值给onclick.那个函数将返回一个事件处理器函数，这个事件处理器函数绑定的是传递进去i 的值，而不是定义在add函数里i的值。 那个被返回的函数被赋值给onclick 7.array.concat(). concat返回一个新数组，是对array的浅复制，并将一个或多个参数添加在后面。 8.array.join（separator）,把一个array构造成一个字符串。 9.pop， push 10.shift， unshift 11.array.slice(start，end)， ，是对array的浅复制，从start开始到end，但不包括end。 12.array.sort（function（a，b）{return a -b}）； 13.array.splice（start，deletecount，item）移除元素 14.string.indexOf ，查找字符串，返回位置否则返回-1 15.string.macth()，匹配一个字符串或正则，返回匹配的值 16.string.replace(searchvalue, replacevalue),返回一个新字符串。 17.string.slice（start, edn）,复制string一部分构造新字符串。 18.string.split（separator，limit）将string分割成片段来创建一个字符串数组。 19.parsrInt,将字符串转换为整数，在遇到非数字时停止解析 20.检测数组的方法： 或者（这个更好）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://pyramidk.github.io/tags/JavaScript/"}]}]}